---
const { item } = Astro.props;

interface Props {
  item: {
    TITLE: string;
    DESCRIPTION: string;
  };
}
---

<section
  id="hero"
  class="relative flex flex-col justify-center items-center gap-8 mx-auto w-full h-screen"
>
  <div
    class="flex lg:flex-row flex-col justify-center items-center gap-14 lg:gap-18 mx-auto w-full max-w-5xl h-full"
  >
    <div
      class="relative flex justify-center items-center w-full lg:w-1/2 overflow-visible"
    >
      <div
        id="canvas-container"
        class="absolute -inset-y-32 inset-x-0 md:-inset-x-24 lg:-inset-48"
      >
      </div>
      <div
        data-aos="zoom-in"
        class="relative flex justify-center items-center bg-black shadow-[inset_0_0_20px_var(--color-blue)] p-4 px-4 border-[5px] border-[var(--color-blue)] rounded-full h-[240px] md:h-[260px] aspect-square"
      >
        <h3
          class="text-white text-3xl md:text-4xl text-center smart-ecosystem-title"
          set:html={item.TITLE}
        />
      </div>
    </div>
    <div
      data-aos="fade-right"
      data-aos-duration="1800"
      class="flex justify-start items-center px-4 w-full lg:w-1/2"
    >
      <p
        class="text-white text-lg lg:text-left text-center"
        set:html={item.DESCRIPTION}
      />
    </div>
  </div>
</section>

<style>
  .smart-ecosystem-title :global(strong) {
    color: var(--color-title);
  }
</style>

<script type="">
  import * as THREE from "https://cdn.skypack.dev/three@0.132.2";

  // --- Control Variables ---
  // Size: Larger values make it bigger. Default is 1.0.
  const sizeMultiplier = 0.84;
  // Speed: Larger values make it faster. Default is 0.0004.
  const speedMultiplier = 0.0009;
  // Sharpness: Larger values make the waves more pronounced and spiky. Default is 1.0.
  const sharpnessMultiplier = 1.4;

  let scene, camera, renderer;
  const particleSystems = [];
  const mouse = new THREE.Vector2(-100, -100); // Initialize off-screen

  function init() {
    const container = document.getElementById("canvas-container");
    if (!container || container.clientWidth === 0) return;

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Create multiple particle systems for a layered effect
    // Layer 1: Main, dense layer
    particleSystems.push(
      createParticleSystem({
        particleCount: 8000,
        radius: 2.5 * sizeMultiplier,
        color: 0x00ccff,
        size: 0.025,
        opacity: 0.8,
        waveConfig: {
          f1: 5,
          a1: 0.1,
          f2: 4,
          a2: 0.15,
          f3: 8,
          a3: 0.08,
          f4: 10,
          a4: 0.05,
        },
      })
    );
    // Layer 2: Outer, sparser layer
    particleSystems.push(
      createParticleSystem({
        particleCount: 4000,
        radius: 2.8 * sizeMultiplier,
        color: 0x00ccff,
        size: 0.03,
        opacity: 0.4,
        waveConfig: {
          f1: 4,
          a1: 0.12,
          f2: 3,
          a2: 0.18,
          f3: 6,
          a3: 0.1,
          f4: 8,
          a4: 0.08,
        },
      })
    );
    // Layer 3: Inner, subtle layer
    particleSystems.push(
      createParticleSystem({
        particleCount: 4000,
        radius: 2.2 * sizeMultiplier,
        color: 0x00aaff,
        size: 0.02,
        opacity: 0.6,
        waveConfig: {
          f1: 6,
          a1: 0.08,
          f2: 5,
          a2: 0.12,
          f3: 10,
          a3: 0.05,
          f4: 12,
          a4: 0.03,
        },
      })
    );

    window.addEventListener("resize", onWindowResize, false);
    renderer.domElement.addEventListener("mousemove", onMouseMove, false);
    renderer.domElement.addEventListener("mouseleave", onMouseLeave, false);
    animate();
  }

  function createParticleSystem(options) {
    const { particleCount, radius, color, size, opacity, waveConfig } = options;

    const particles = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const sphericalData = new Float32Array(particleCount * 3);
    const originalPositions = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const phi = Math.acos(-1 + (2 * i) / particleCount);
      const theta = Math.sqrt(particleCount * Math.PI) * phi;

      sphericalData[i3] = radius;
      sphericalData[i3 + 1] = phi;
      sphericalData[i3 + 2] = theta;

      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);

      positions[i3] = x;
      positions[i3 + 1] = y;
      positions[i3 + 2] = z;

      originalPositions[i3] = x;
      originalPositions[i3 + 1] = y;
      originalPositions[i3 + 2] = z;
    }

    particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    particles.setAttribute(
      "sphericalData",
      new THREE.BufferAttribute(sphericalData, 3)
    );
    particles.setAttribute(
      "originalPosition",
      new THREE.BufferAttribute(originalPositions, 3)
    );
    particles.userData.waveConfig = waveConfig; // Store wave config

    const particleMaterial = new THREE.PointsMaterial({
      color: color,
      size: size,
      transparent: true,
      blending: THREE.AdditiveBlending,
      opacity: opacity,
      sizeAttenuation: true,
    });

    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);
    return particleSystem;
  }

  function onWindowResize() {
    const container = document.getElementById("canvas-container");
    if (!container || container.clientWidth === 0) return;

    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  }

  function onMouseMove(event) {
    const container = document.getElementById("canvas-container");
    if (!container) return;
    const rect = container.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  }

  function onMouseLeave() {
    mouse.x = -100;
    mouse.y = -100;
  }

  function animate() {
    requestAnimationFrame(animate);

    const time = Date.now() * speedMultiplier;
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    particleSystems.forEach((particleSystem, index) => {
      const positions = particleSystem.geometry.attributes.position.array;
      const sphericalData =
        particleSystem.geometry.attributes.sphericalData.array;
      const originalPositions =
        particleSystem.geometry.attributes.originalPosition.array;
      const particleCount = particleSystem.geometry.attributes.position.count;
      const wc = particleSystem.geometry.userData.waveConfig;
      const timeOffset = time + index * 0.5; // Desynchronize animations

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const baseRadius = sphericalData[i3];
        const phi = sphericalData[i3 + 1];
        const theta = sphericalData[i3 + 2];

        // --- Wave Animation ---
        let displacement = Math.sin(phi * wc.f1 + timeOffset) * wc.a1;
        displacement += Math.cos(theta * wc.f2 + timeOffset * 0.8) * wc.a2;
        displacement +=
          Math.sin(phi * wc.f3 + theta * (wc.f3 / 2) + timeOffset * 1.2) *
          wc.a3;
        displacement +=
          Math.sin(phi * wc.f4 + theta * (wc.f4 / 2) + timeOffset * 1.5) *
          wc.a4;
        displacement *= sharpnessMultiplier;
        const finalRadius = baseRadius + displacement;

        let x = finalRadius * Math.sin(phi) * Math.cos(theta);
        let y = finalRadius * Math.sin(phi) * Math.sin(theta);
        let z = finalRadius * Math.cos(phi);

        // --- Mouse Interaction ---
        const particlePos = new THREE.Vector3(x, y, z);
        const mouseWorldPos = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        mouseWorldPos.unproject(camera);
        const dir = mouseWorldPos.sub(camera.position).normalize();
        const distanceToParticle = particlePos.distanceTo(camera.position);
        const mousePoint = camera.position
          .clone()
          .add(dir.multiplyScalar(distanceToParticle));

        const dist = particlePos.distanceTo(mousePoint);
        const maxDist = 1; // Interaction radius

        if (dist < maxDist) {
          const force = (maxDist - dist) * 0.8;
          const direction = particlePos.clone().sub(mousePoint).normalize();
          particlePos.add(direction.multiplyScalar(force));

          // Gradually return to original position
          positions[i3] += (particlePos.x - positions[i3]) * 0.08;
          positions[i3 + 1] += (particlePos.y - positions[i3 + 1]) * 0.08;
          positions[i3 + 2] += (particlePos.z - positions[i3 + 2]) * 0.08;
        } else {
          // Gradually return to wave-animated position if not interacting
          positions[i3] += (x - positions[i3]) * 0.05;
          positions[i3 + 1] += (y - positions[i3 + 1]) * 0.05;
          positions[i3 + 2] += (z - positions[i3 + 2]) * 0.05;
        }
      }

      particleSystem.geometry.attributes.position.needsUpdate = true;
      particleSystem.rotation.x += 0.0001 * (index * 0.2 + 1);
      particleSystem.rotation.y += 0.0002 * (index * 0.2 + 1);
    });

    renderer.render(scene, camera);
  }

  setTimeout(init, 100);
</script>
